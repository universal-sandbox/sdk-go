// This file was auto-generated by Fern from our API Definition.

package sandbox

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/universal-sandbox/sdk-go/core"
)

// Request to create a new sandbox (type is specified in URL path).
type CreateSandboxRequest struct {
	// Provider to use (auto-detected if not specified)
	Provider *SandboxProvider `json:"provider,omitempty" url:"provider,omitempty"`
	// Preferred region for the sandbox
	Region *string `json:"region,omitempty" url:"region,omitempty"`
	// Timeout in minutes
	Timeout *int `json:"timeout,omitempty" url:"timeout,omitempty"`
	// Additional metadata
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateSandboxRequest) GetProvider() *SandboxProvider {
	if c == nil {
		return nil
	}
	return c.Provider
}

func (c *CreateSandboxRequest) GetRegion() *string {
	if c == nil {
		return nil
	}
	return c.Region
}

func (c *CreateSandboxRequest) GetTimeout() *int {
	if c == nil {
		return nil
	}
	return c.Timeout
}

func (c *CreateSandboxRequest) GetMetadata() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateSandboxRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateSandboxRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateSandboxRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateSandboxRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateSandboxRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Request to execute a command in a sandbox.
type ExecuteRequest struct {
	// Command or code to execute
	Command string `json:"command" url:"command"`
	// Execution timeout in seconds
	Timeout *int `json:"timeout,omitempty" url:"timeout,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *ExecuteRequest) GetCommand() string {
	if e == nil {
		return ""
	}
	return e.Command
}

func (e *ExecuteRequest) GetTimeout() *int {
	if e == nil {
		return nil
	}
	return e.Timeout
}

func (e *ExecuteRequest) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExecuteRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ExecuteRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExecuteRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExecuteRequest) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Response from command execution.
type ExecuteResponse struct {
	Stdout   *string `json:"stdout,omitempty" url:"stdout,omitempty"`
	Stderr   *string `json:"stderr,omitempty" url:"stderr,omitempty"`
	ExitCode *int    `json:"exit_code,omitempty" url:"exit_code,omitempty"`
	Error    *string `json:"error,omitempty" url:"error,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *ExecuteResponse) GetStdout() *string {
	if e == nil {
		return nil
	}
	return e.Stdout
}

func (e *ExecuteResponse) GetStderr() *string {
	if e == nil {
		return nil
	}
	return e.Stderr
}

func (e *ExecuteResponse) GetExitCode() *int {
	if e == nil {
		return nil
	}
	return e.ExitCode
}

func (e *ExecuteResponse) GetError() *string {
	if e == nil {
		return nil
	}
	return e.Error
}

func (e *ExecuteResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExecuteResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ExecuteResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExecuteResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExecuteResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type HttpValidationError struct {
	Detail []*ValidationError `json:"detail,omitempty" url:"detail,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (h *HttpValidationError) GetDetail() []*ValidationError {
	if h == nil {
		return nil
	}
	return h.Detail
}

func (h *HttpValidationError) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HttpValidationError) UnmarshalJSON(data []byte) error {
	type unmarshaler HttpValidationError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HttpValidationError(value)

	extraProperties, err := core.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties

	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HttpValidationError) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

// Health status information.
type HealthStatus struct {
	// Whether the service is healthy
	IsHealthy bool `json:"is_healthy" url:"is_healthy"`
	// Health status description
	Status    string                 `json:"status" url:"status"`
	Details   map[string]interface{} `json:"details,omitempty" url:"details,omitempty"`
	CheckedAt *string                `json:"checked_at,omitempty" url:"checked_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (h *HealthStatus) GetIsHealthy() bool {
	if h == nil {
		return false
	}
	return h.IsHealthy
}

func (h *HealthStatus) GetStatus() string {
	if h == nil {
		return ""
	}
	return h.Status
}

func (h *HealthStatus) GetDetails() map[string]interface{} {
	if h == nil {
		return nil
	}
	return h.Details
}

func (h *HealthStatus) GetCheckedAt() *string {
	if h == nil {
		return nil
	}
	return h.CheckedAt
}

func (h *HealthStatus) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HealthStatus) UnmarshalJSON(data []byte) error {
	type unmarshaler HealthStatus
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HealthStatus(value)

	extraProperties, err := core.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties

	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HealthStatus) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

// Resource limits response.
type LimitsResponse struct {
	Limits       map[string]int `json:"limits,omitempty" url:"limits,omitempty"`
	CurrentUsage map[string]int `json:"current_usage,omitempty" url:"current_usage,omitempty"`
	Timestamp    string         `json:"timestamp" url:"timestamp"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LimitsResponse) GetLimits() map[string]int {
	if l == nil {
		return nil
	}
	return l.Limits
}

func (l *LimitsResponse) GetCurrentUsage() map[string]int {
	if l == nil {
		return nil
	}
	return l.CurrentUsage
}

func (l *LimitsResponse) GetTimestamp() string {
	if l == nil {
		return ""
	}
	return l.Timestamp
}

func (l *LimitsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LimitsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler LimitsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LimitsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LimitsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Sandbox provider.
type SandboxProvider string

const (
	SandboxProviderE2B        SandboxProvider = "e2b"
	SandboxProviderVolcengine SandboxProvider = "volcengine"
	SandboxProviderAws        SandboxProvider = "aws"
	SandboxProviderAlibaba    SandboxProvider = "alibaba"
)

func NewSandboxProviderFromString(s string) (SandboxProvider, error) {
	switch s {
	case "e2b":
		return SandboxProviderE2B, nil
	case "volcengine":
		return SandboxProviderVolcengine, nil
	case "aws":
		return SandboxProviderAws, nil
	case "alibaba":
		return SandboxProviderAlibaba, nil
	}
	var t SandboxProvider
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SandboxProvider) Ptr() *SandboxProvider {
	return &s
}

// Response containing sandbox details.
type SandboxResponse struct {
	Id        string       `json:"id" url:"id"`
	Type      string       `json:"type" url:"type"`
	Provider  string       `json:"provider" url:"provider"`
	Region    *string      `json:"region,omitempty" url:"region,omitempty"`
	Status    string       `json:"status" url:"status"`
	CreatedAt string       `json:"created_at" url:"created_at"`
	ExpiresAt *string      `json:"expires_at,omitempty" url:"expires_at,omitempty"`
	Urls      *SandboxUrls `json:"urls,omitempty" url:"urls,omitempty"`
	Timeout   *int         `json:"timeout,omitempty" url:"timeout,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SandboxResponse) GetId() string {
	if s == nil {
		return ""
	}
	return s.Id
}

func (s *SandboxResponse) GetType() string {
	if s == nil {
		return ""
	}
	return s.Type
}

func (s *SandboxResponse) GetProvider() string {
	if s == nil {
		return ""
	}
	return s.Provider
}

func (s *SandboxResponse) GetRegion() *string {
	if s == nil {
		return nil
	}
	return s.Region
}

func (s *SandboxResponse) GetStatus() string {
	if s == nil {
		return ""
	}
	return s.Status
}

func (s *SandboxResponse) GetCreatedAt() string {
	if s == nil {
		return ""
	}
	return s.CreatedAt
}

func (s *SandboxResponse) GetExpiresAt() *string {
	if s == nil {
		return nil
	}
	return s.ExpiresAt
}

func (s *SandboxResponse) GetUrls() *SandboxUrls {
	if s == nil {
		return nil
	}
	return s.Urls
}

func (s *SandboxResponse) GetTimeout() *int {
	if s == nil {
		return nil
	}
	return s.Timeout
}

func (s *SandboxResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SandboxResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SandboxResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SandboxResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SandboxResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// URLs associated with a sandbox.
type SandboxUrls struct {
	WssUrl *string `json:"wss_url,omitempty" url:"wss_url,omitempty"`
	VncUrl *string `json:"vnc_url,omitempty" url:"vnc_url,omitempty"`
	McpUrl *string `json:"mcp_url,omitempty" url:"mcp_url,omitempty"`
	ApiUrl *string `json:"api_url,omitempty" url:"api_url,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SandboxUrls) GetWssUrl() *string {
	if s == nil {
		return nil
	}
	return s.WssUrl
}

func (s *SandboxUrls) GetVncUrl() *string {
	if s == nil {
		return nil
	}
	return s.VncUrl
}

func (s *SandboxUrls) GetMcpUrl() *string {
	if s == nil {
		return nil
	}
	return s.McpUrl
}

func (s *SandboxUrls) GetApiUrl() *string {
	if s == nil {
		return nil
	}
	return s.ApiUrl
}

func (s *SandboxUrls) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SandboxUrls) UnmarshalJSON(data []byte) error {
	type unmarshaler SandboxUrls
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SandboxUrls(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SandboxUrls) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ValidationError struct {
	Loc  []*ValidationErrorLocItem `json:"loc,omitempty" url:"loc,omitempty"`
	Msg  string                    `json:"msg" url:"msg"`
	Type string                    `json:"type" url:"type"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *ValidationError) GetLoc() []*ValidationErrorLocItem {
	if v == nil {
		return nil
	}
	return v.Loc
}

func (v *ValidationError) GetMsg() string {
	if v == nil {
		return ""
	}
	return v.Msg
}

func (v *ValidationError) GetType() string {
	if v == nil {
		return ""
	}
	return v.Type
}

func (v *ValidationError) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *ValidationError) UnmarshalJSON(data []byte) error {
	type unmarshaler ValidationError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = ValidationError(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *ValidationError) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type ValidationErrorLocItem struct {
	String  string
	Integer int

	typ string
}

func NewValidationErrorLocItemFromString(value string) *ValidationErrorLocItem {
	return &ValidationErrorLocItem{typ: "String", String: value}
}

func NewValidationErrorLocItemFromInteger(value int) *ValidationErrorLocItem {
	return &ValidationErrorLocItem{typ: "Integer", Integer: value}
}

func (v *ValidationErrorLocItem) GetString() string {
	if v == nil {
		return ""
	}
	return v.String
}

func (v *ValidationErrorLocItem) GetInteger() int {
	if v == nil {
		return 0
	}
	return v.Integer
}

func (v *ValidationErrorLocItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		v.typ = "String"
		v.String = valueString
		return nil
	}
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		v.typ = "Integer"
		v.Integer = valueInteger
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v ValidationErrorLocItem) MarshalJSON() ([]byte, error) {
	if v.typ == "String" || v.String != "" {
		return json.Marshal(v.String)
	}
	if v.typ == "Integer" || v.Integer != 0 {
		return json.Marshal(v.Integer)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", v)
}

type ValidationErrorLocItemVisitor interface {
	VisitString(string) error
	VisitInteger(int) error
}

func (v *ValidationErrorLocItem) Accept(visitor ValidationErrorLocItemVisitor) error {
	if v.typ == "String" || v.String != "" {
		return visitor.VisitString(v.String)
	}
	if v.typ == "Integer" || v.Integer != 0 {
		return visitor.VisitInteger(v.Integer)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", v)
}
